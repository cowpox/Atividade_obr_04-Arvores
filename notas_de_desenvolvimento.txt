01) Plano de implementação das funções: das mais básicas para as mais avançadas
    Buscar (buscar)
    Inserir (inserir)
    Remover uma ocorrência (removerUmaOcorrencia)
    Remover todas as ocorrências (removerTodasOcorrencias)
    Percursos (exibirInOrder)
    Contar nós (contarNos)
    Contar total de elementos (contarTotalElementos)
    k-ésimo menor (kEsimoMenor)
    Imprimir intervalo (imprimirIntervalo)
    LCA (lowestCommonAncestor)

02) Função buscar:
    retorna: o nó do valor ou NULL (caso não exista)
    lógica: vamos utilizar a recursiva
        raiz == NULL, retorna NULL
        valor == raiz->chave, retorna raiz
        valor < raiz->chave, busca sub-árvore esquerda
        valor > raiz->chave, busca sub-árvore direita
    teste:
        1 - erro (não localizou o 5)
        2 - funcionando (OK)


03) Função inserir:
    retorna: ponteiro de nó
    lógica: recursiva
        raiz == NULL, cria novo nó e retorna
        senão:
            valor < raiz->chave, insira na subárvore esquerda
            valor > raiz->chave, insira na subárvore direita
            valor == raiz->chave, incrementa contador e não cria nono nó
        retorna a nova raiz (importante para recursão)
    teste:
        1 - ainda sem conseguir avaliar
        2 - funcionando (OK)

04) Revisar a função inicializar
    recebe: ponteiro de ponteiro
    retorna: void
    lógica: permite modificar a variável raiz diretamente no main
        define a raiz como NULL (árvore vazia)
    teste: realizado com sucesso (OK)

05) Revisar a função criarNo
    recebe: valor
    retorna: ponteiro para o novo nó
    lógica: 
        aloca memória para novo nó
        preenche: chave (com valor), contador com 1, esq e dir com NULL
    teste: realizado com sucesso (OK)

06) Modificar a inserção de valores no main (atribuir a um ponteiro)
falta fazer a revisão!!!
Revisado => ok

07) Função removerUmaOcorrencia
    recebe: ponteiro para raiz e o valor a ser removido
    retorna: ponteiro da raiz (pois pode ser diferente)
    lógica: remove apenas 1 cópia do valor
        busca o nó que contenha o valor (durante o percurso da excludência)
        se não encontrado, não faz nada (retorna a raiz)
        se encontrado e contador maior que 1 => só decrementa o contador em 1
        se encontrado e contador == 1 => faz a remoção tradicional
    obs: não há necessidade de usar a função buscar, para não percorrer a árvore 2 x
    teste:
        1 - ainda não realizado
        2 - funcionando (OK)

08) Implementar a função exibirInOrder (para poder testar as funções de remoção)
    recebe: ponteiro para a raiz
    exibe: os elementos da árvore em ordem crescente
    retorna: void
    lógica: recursiva
        visita subárvore esquerda
        imprime nó
        visita subárvore direita
    teste: exibiu em ordem crescente. Funcionando (OK)

09) Realizar testes com as funções já implementadas
    realizados os testes. Todas as funções implementadas até aqui estão funcionando

10) Função removerTodasOcorrencias
    recebe: ponteiro para raiz e o valor a ser removido
    retorna: ponteiro da raiz (que pode ser diferente)
    lógica: remove completamente o nó, independente do contador
        busca o nó que contenha o valor (durante o percurso da excludência)
        se não encontrado, não faz nada (retorna a raiz)
        se encontrado => faz a remoção tradicional
    teste: funcionando (OK)


